/*******************************************************************************
 * CLI - A simple command line interface.
 * Copyright (C) 2016-2021 Daniele Pallastrelli
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

#ifndef CLI_DETAIL_FROMSTRING_H_
#define CLI_DETAIL_FROMSTRING_H_

// #define CLI_FROMSTRING_USE_BOOST

#ifdef CLI_FROMSTRING_USE_BOOST

#include <boost/lexical_cast.hpp>

namespace cli
{
namespace detail
{

template <typename T>
inline
T from_string(const std::string& s)
{
    return boost::lexical_cast<T>(s);
}

} // namespace detail
} // namespace cli

#else

#include <limits>
#include <string>
#include <sstream>
#include <cctype>
#include <cstdlib>

namespace cli
{

    namespace detail
    {
        enum class parse_errc { ok=0, invalid, overflow };

template <typename T>
inline bool from_string(const std::string& s, T& out);

template <>
inline bool from_string(const std::string& s, std::string& out)
{
    out = s;
    return true;
}

template <>
inline bool from_string(const std::string& /*s*/, std::nullptr_t& out)
{
    out = nullptr;
    return true;
}

namespace detail
{

template <typename T>
inline bool unsigned_digits_from_string(const std::string& s, T& result)
{
    if (s.empty())
        return false;
    result = 0;
    for (char c: s)
    {
        if (!std::isdigit(static_cast<unsigned char>(c)))
            return false;
        const T digit = static_cast<T>( c - '0' );
        const T tmp = (result * 10) + digit;
        if (result != ((tmp-digit)/10) || (tmp < result))
            return false;
        result = tmp;
    }
    return true;
}

template <typename T>
inline bool unsigned_from_string(std::string s, T& out)
{
    if (s.empty())
        return false;
    if (s[0] == '+')
    {
        s = s.substr(1);
    }
    return unsigned_digits_from_string<T>(s, out);
}

template <typename T>
inline bool signed_from_string(std::string s, T& out)
{
    if (s.empty())
        return false;
    using U = std::make_unsigned_t<T>;
    if (s[0] == '-')
    {
        s = s.substr(1);
        U val{};
        if (!unsigned_digits_from_string<U>(s, val)) return false;
        auto min = std::numeric_limits<T>::min(); // this to avoid overflow warnings. Please NOTE: const auto produces warning!
        if ( val > static_cast<U>( - min ) )
            return false;
        out = (- static_cast<T>(val));
        return true;
    }
    else if (s[0] == '+')
    {
        s = s.substr(1);
    }
    U val{};
    if (!unsigned_digits_from_string<U>(s, val)) return false;
    if (val > static_cast<U>( std::numeric_limits<T>::max() ))
        return false;
    out = static_cast<T>(val);
    return true;
}

} // namespace detail

// signed

template <> inline bool 
from_string(const std::string& s, signed char& out) { return detail::signed_from_string<signed char>(s, out); }

template <> inline bool 
from_string(const std::string& s, short int& out) { return detail::signed_from_string<short int>(s, out); }

template <> inline bool
from_string(const std::string& s, int& out) { return detail::signed_from_string<int>(s, out); }

template <> inline bool
from_string(const std::string& s, long int& out) { return detail::signed_from_string<long int>(s, out); }

template <> inline bool
from_string(const std::string& s, long long int& out) { return detail::signed_from_string<long long int>(s, out); }

// unsigned

template <> inline bool
from_string(const std::string& s, unsigned char& out) { return detail::unsigned_from_string<unsigned char>(s, out); }

template <> inline bool
from_string(const std::string& s, unsigned short int& out) { return detail::unsigned_from_string<unsigned short int>(s, out); }

template <> inline bool
from_string(const std::string& s, unsigned int& out) { return detail::unsigned_from_string<unsigned int>(s, out); }

template <> inline bool
from_string(const std::string& s, unsigned long int& out) { return detail::unsigned_from_string<unsigned long int>(s, out); }

template <> inline bool
from_string(const std::string& s, unsigned long long int& out) { return detail::unsigned_from_string<unsigned long long int>(s, out); }

// bool

template <>
inline bool from_string(const std::string& s, bool& out)
{
    if (s == "true") { out = true; return true; }
    else if (s == "false") { out = false; return true; }
    long long int value{};
    if (!detail::signed_from_string<long long int>(s, value)) return false;
    if (value == 1) { out = true; return true; }
    else if (value == 0) { out = false; return true; }
    return false;           
}

// chars

template <>
inline bool from_string(const std::string& s, char& out)
{
    if (s.size() != 1) return false;
    out = s[0];
    return true;           
}

// floating points

template <>
inline bool from_string(const std::string& s, float& out)
{
    if ( std::any_of(s.begin(), s.end(), [](char c){return std::isspace(static_cast<unsigned char>(c));} ) )
        return false;
    out = 0.0f;
    char *endptr = nullptr;
    out = std::strtof(s.c_str(), &endptr);
    if (endptr != s.c_str() + s.size())
        return false;
    return true;
}

template <>
inline bool from_string(const std::string& s, double& out)
{
    if ( std::any_of(s.begin(), s.end(), [](char c){return std::isspace(static_cast<unsigned char>(c));} ) )
        return false;
    out = 0.0;
    char *endptr = nullptr;
    out = std::strtod(s.c_str(), &endptr);
    if (endptr != s.c_str() + s.size())
        return false;
    return true;
}

template <>
inline bool from_string(const std::string& s, long double& out)
{
    if ( std::any_of(s.begin(), s.end(), [](char c){return std::isspace(static_cast<unsigned char>(c));} ) )
        return false;
    out = 0.0;
    char *endptr = nullptr;
    out = std::strtold(s.c_str(), &endptr);
    if (endptr != s.c_str() + s.size())
        return false;
    return true;
}

// fallback: operator <<

template <typename T>
inline bool from_string(const std::string& s, T& out)
{
    std::stringstream interpreter;

    if(!(interpreter << s) ||
        !(interpreter >> out) ||
        !(interpreter >> std::ws).eof())
        return false;

    return true;
}

    } // namespace detail

} // namespace cli


#endif // CLI_FROMSTRING_USE_BOOST

#endif // CLI_DETAIL_FROMSTRING_H_
